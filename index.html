<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Ерошен SOJU Jump</title>
<style>
  body, html {
    margin: 0; padding: 0; overflow: hidden;
    background: #121212;
    color: #ddd;
    font-family: Arial, sans-serif;
    user-select: none;
    touch-action: manipulation;
  }
  canvas {
    image-rendering: -moz-crisp-edges;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
    display: block;
    background: #222;
    margin: 0 auto;
    /* Масштабируем canvas через css transform */
  transform-origin: center center;
  position: absolute;
  top: 50%;
  left: 50%;
  }
  #startScreen, #gameOverScreen, #loadingScreen {
    position: fixed;
    top: 0; left: 0; width: 100vw; height: 100vh;
    background: rgba(0,0,0,0.85);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 10;
    flex-direction: column;
    color: white;
    font-size: 36px;
    user-select: none;
  }
  #loadingScreen {
    display: none;
  }
  button {
    font-size: 28px;
    padding: 15px 40px;
    cursor: pointer;
    border: none;
    background: #6a0dad;
    color: #fff;
    border-radius: 10px;
    margin-top: 20px;
  }
  #score {
    position: fixed;
    top: 10px; left: 50%;
    transform: translateX(-50%);
    font-size: 24px;
    display: none;
    z-index: 5;
    transition: transform 0.2s ease-out;
  }
  #score.bounce {
  transform: translateX(-50%) scale(1.1);
  }
  /* Мобильные кнопки управления */
  #mobileControls {
    position: fixed;
    bottom: 20px;
    width: 100%;
    text-align: center;
    z-index: 15;
  }
  #mobileControls button {
    font-size: 32px;
    padding: 15px 25px;
    margin: 0 10px;
    border-radius: 50%;
    background: rgba(106, 13, 173, 0.8);
    color: white;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
  }
  #mobileControls button:active {
    background: rgba(106, 13, 173, 1);
  }
#lives {
  color: red;
  font-weight: bold;
  text-shadow: 1px 1px 2px black;
  display: flex;
  gap: 5px;
  align-items: center;
}
</style>
</head>
<body>
<div id="livesCount" style="position: fixed; top: 10px; left: 10px; font-size: 24px;"></div>

<div id="startScreen">
  <button id="startBtn">Старт</button>
</div>

<div id="gameOverScreen" style="display:none;">
  <div>Игра окончена</div>
  <button id="restartBtn">Играть заново</button>
</div>

<div id="loadingScreen">
  Загрузка...
</div>

<div id="score">Очки: 0</div>

<canvas id="gameCanvas"></canvas>

<!-- Мобильные кнопки (УБРАЛ кнопку прыжка) -->
<div id="mobileControls" style="display:none;">
  <button id="leftBtn">⬅️</button>
  <!-- <button id="jumpBtn">⬆️</button>  Удалил кнопку прыжка -->
  <button id="rightBtn">➡️</button>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let scale = 1;
const BASE_WIDTH = 960;
const BASE_HEIGHT = 800;

function resize() {
  const scaleX = window.innerWidth / BASE_WIDTH;
  const scaleY = window.innerHeight / BASE_HEIGHT;
  scale = Math.max(0.5, Math.min(scaleX, scaleY));
  canvas.style.transform = `translate(-50%, -50%) scale(${scale})`;
  canvas.width = BASE_WIDTH;
  canvas.height = BASE_HEIGHT;
}
resize();
window.addEventListener('resize', resize);

// Теперь объявляем размеры после инициализации canvas
const WIDTH = canvas.width;
const HEIGHT = canvas.height;
let visualScore = 0; // Для плавного отображения
let scoreAnimationFrame = null; // Для анимации счета
let totalHeight = 0; // Общая высота подъема в игровом мире
const heightScoreMultiplier = 0.1; // Множитель для очков
const SCORE_SPEED = 0.3; // Скорость плавного начисления (0.1-1)
let lastPlayerY = HEIGHT;


function resize() {
  const scaleX = window.innerWidth / BASE_WIDTH;
  const scaleY = window.innerHeight / BASE_HEIGHT;
  scale = Math.max(0.5, Math.min(scaleX, scaleY));
   canvas.style.transform = `translate(-50%, -50%) scale(${scale})`;
  canvas.width = BASE_WIDTH;
  canvas.height = BASE_HEIGHT;
}
resize();
window.addEventListener('resize', resize);

let gameStarted = false;
let gameOver = false;
let score = 0;
let maxHeight = HEIGHT; // Изначально равна нижней границе (игрок стартует внизу)
let scorePerPixel = 0.5; // Сколько очков давать за 1 пиксель высоты
const scoreDiv = document.getElementById('score');

const startScreen = document.getElementById('startScreen');
const gameOverScreen = document.getElementById('gameOverScreen');
const loadingScreen = document.getElementById('loadingScreen');
const startBtn = document.getElementById('startBtn');
const restartBtn = document.getElementById('restartBtn');

class Platform {
  constructor(x, y, isDestructible = false) {
    this.x = x;
    this.y = y;
    this.width = 90;
    this.height = 30;
    this.isDestructible = isDestructible;
    this.destroyTime = 7;
    this.destroyTimer = 0;
    this.isDestroying = false;
    this.damageProgress = 0; // Добавляем инициализацию
  }

  startDestruction() {
    if (this.isDestructible && !this.isDestroying) {
      this.isDestroying = true;
      this.destroyTimer = 0;
      this.damageProgress = 0;
    }
  }

  update(deltaTime) {
    if (!this.isDestructible || !this.isDestroying) return false;
    
    this.destroyTimer += deltaTime;
    this.damageProgress = Math.min(1, this.destroyTimer / this.destroyTime);
    if (this.damageProgress > 0.7 && player.currentPlatform === this) {
    player.vy = -player.jumpPower * 0.6;
    player.currentPlatform = null;
    }
    return this.destroyTimer >= this.destroyTime;
  }

  draw(isCurrentPlatform) { // Принимаем параметр - является ли текущей
    // Основной цвет
    if (this.isDestructible && this.damageProgress >= 1) return;
    // Эффект дрожания
    const shakeOffset = this.isDestroying && this.damageProgress > 0.7 ? 
        (Math.random() - 0.5) * 3 * this.damageProgress : 0;
        ctx.save();
    ctx.translate(shakeOffset, 0);
    if (this.isDestructible) {
      const grayValue = 180 - Math.floor(80 * this.damageProgress);
      ctx.fillStyle = `rgb(${grayValue},${grayValue},${grayValue})`;
    } else {
      ctx.fillStyle = '#4caf50';
    }
    // Рисуем основу
    ctx.beginPath();
    ctx.ellipse(this.x + this.width/2, this.y + this.height/2,
                this.width/2, this.height/2, 0, 0, Math.PI*2);
    ctx.fill();

    // Таймер и трещины только для текущей разрушаемой платформы
    // Таймер и трещины для текущей разрушаемой платформы
  if (this.isDestructible && this.isDestroying && isCurrentPlatform) {
    // Трещины
    ctx.strokeStyle = `rgba(139,0,0,${this.damageProgress})`;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(this.x + this.width/2, this.y + 5);
    ctx.lineTo(this.x + this.width/2, this.y + this.height - 5);
    ctx.moveTo(this.x + 5, this.y + this.height/2);
    ctx.lineTo(this.x + this.width - 5, this.y + this.height/2);
    ctx.stroke();
    
    // Таймер (всегда виден для текущей платформы)
    ctx.fillStyle = 'red';
    ctx.font = 'bold 16px Arial';
    const timeLeft = Math.max(0, this.destroyTime - this.destroyTimer);
    ctx.fillText(
      timeLeft.toFixed(1),
      this.x + this.width/2,
      this.y - 10
    );
  }ctx.restore();
}
}


class Player {
  constructor() {
    this.width = 60;
    this.height = 100;
    this.x = WIDTH/2 - this.width/2;
    this.y = HEIGHT - this.height - 10;  // 10 — отступ от низа
    this.vx = 0;
    this.vy = 0;
    this.gravity = 600;
    this.jumpPower = 600;
    this.speedX = 500;
    this.onPlatform = false;
    this.canJump = true; // Добавляем флаг возможности прыжка
    this.hasJumpedOnce = false;
    this.currentPlatform = null;
    this.wasOnPlatform = false;
    this.maxFallThroughTime = 0.2; 
    this.lives = 3; // Добавляем 3 жизни
    this.hearts = [];
    this.initHearts();
    this.invulnerable = false;
    this.invulnerableTimer = 0;
    this.invulnerableDuration = 1.5;
  }
  initHearts() {
    const heartSize = 24;
    const rightMargin = 30;
    const topMargin = 30;
    const spacing = 10;
    
    for (let i = 0; i < this.lives; i++) {
      this.hearts.push({
        x: WIDTH - rightMargin - (i * (heartSize + spacing)),
        y: topMargin,
        size: heartSize,
        visible: true
      });
    }
  }
  loseLife() {
    if (!this.invulnerable) {
      this.lives--;
      this.invulnerable = true;
      this.invulnerableTimer = 0;
      // Эффект мигания при получении урона
      this.blinkEffect = true;
      return true; // Возвращаем true, если жизнь была потеряна
    }
    return false;
  }
   draw() {
        ctx.save();
        
        // Эффект повреждения (мигание)
        if (this.invulnerable && Math.floor(this.invulnerableTimer * 10) % 2 === 0) {
            ctx.globalAlpha = 0.5;
        }

        // ### Анатомически правильные пропорции ###
        const headRadius = 12;
        const neckLength = 5;
        const shoulderWidth = 30;
        const armLength = 25;
        const torsoHeight = 30;
        const legLength = 40;

        // ### Голова ###
        // Лицо (овальное)
        ctx.fillStyle = '#F5D6B3'; // Цвет кожи
        ctx.beginPath();
        ctx.ellipse(
            this.x + 30, 
            this.y + headRadius, 
            headRadius, 
            headRadius * 1.2, 
            0, 0, Math.PI * 2
        );
        ctx.fill();

        // Волосы (под кепкой)
        ctx.fillStyle = '#2A190E';
        ctx.beginPath();
        ctx.arc(
            this.x + 30, 
            this.y + headRadius, 
            headRadius, 
            Math.PI * 0.9, 
            Math.PI * 2.1
        );
        ctx.fill();

        // ### Кепка РЖД (детализированная) ###
        ctx.fillStyle = '#1A3A8F';
        // Козырёк
        ctx.beginPath();
        ctx.moveTo(this.x + 15, this.y + headRadius + 3);
        ctx.lineTo(this.x + 45, this.y + headRadius + 3);
        ctx.lineTo(this.x + 42, this.y + headRadius);
        ctx.lineTo(this.x + 18, this.y + headRadius);
        ctx.closePath();
        ctx.fill();
        
        // Тулья кепки
        ctx.beginPath();
        ctx.arc(
            this.x + 30, 
            this.y + headRadius - 2, 
            headRadius * 0.9, 
            Math.PI, 
            0
        );
        ctx.fill();

        // Логотип РЖД
        ctx.fillStyle = '#FFFFFF';
        ctx.font = 'bold 9px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('РЖД', this.x + 30, this.y + headRadius + 2);

        // ### Шея ###
        ctx.fillStyle = '#E6C9A8'; // Темнее кожи
        ctx.fillRect(
            this.x + 28, 
            this.y + headRadius * 2, 
            4, 
            neckLength
        );

        // ### Плечи и торс ###
        // Куртка "Норникель"
        ctx.fillStyle = '#000000';
        // Левое плечо
        ctx.beginPath();
        ctx.ellipse(
            this.x + 15, 
            this.y + headRadius * 2 + neckLength, 
            8, 
            5, 
            Math.PI/4, 0, Math.PI * 2
        );
        ctx.fill();
        
        // Правое плечо
        ctx.beginPath();
        ctx.ellipse(
            this.x + 45, 
            this.y + headRadius * 2 + neckLength, 
            8, 
            5, 
            -Math.PI/4, 0, Math.PI * 2
        );
        ctx.fill();

        // Торс
        ctx.fillRect(
            this.x + 15, 
            this.y + headRadius * 2 + neckLength, 
            shoulderWidth, 
            torsoHeight
        );

        // Надпись "НОРНИКЕЛЬ" с эффектом кривизны
        ctx.fillStyle = '#FFFFFF';
        ctx.font = 'bold 6px Arial';
        ctx.textAlign = 'center';
        // Первая строка "НОРНИ"
for (let i = 0; i < 5; i++) {
    const letter = 'НОРНИ'[i];
    const offsetY = Math.sin(i * 0.4) * 1.5; // Меньшая амплитуда волны
    ctx.fillText(
        letter,
        this.x + 20 + i * 7, // Более плотное расположение букв
        this.y + headRadius * 2 + neckLength + 18 + offsetY
    );
}

// Вторая строка "КЕЛЬ"
for (let i = 0; i < 4; i++) {
    const letter = 'КЕЛЬ'[i];
    const offsetY = Math.sin(i * 0.4) * 1.5;
    ctx.fillText(
        letter,
        this.x + 22 + i * 7,
        this.y + headRadius * 2 + neckLength + 26 + offsetY
    );
}

        // ### Руки ###
        // Левая рука с пачкой сигарет
        ctx.fillStyle = '#F5D6B3';
        ctx.beginPath();
        ctx.roundRect(
            this.x + 5, 
            this.y + headRadius * 2 + neckLength + 5, 
            10, 
            armLength, 
            [5]
        );
        ctx.fill();

        // Пачка сигарет
        ctx.fillStyle = '#3A2B1E';
        ctx.beginPath();
        ctx.roundRect(
            this.x, 
            this.y + headRadius * 2 + neckLength + 15, 
            12, 
            15, 
            [3]
        );
        ctx.fill();

        // Надпись "Captain Black"
        ctx.fillStyle = '#FFFFFF';
        ctx.font = 'italic 6px Arial';
        ctx.fillText('Captain', this.x + 2, this.y + headRadius * 2 + neckLength + 22);
        ctx.fillText('Black', this.x + 4, this.y + headRadius * 2 + neckLength + 28);

        // Правая рука с сигаретой
        ctx.fillStyle = '#F5D6B3';
        ctx.beginPath();
        ctx.roundRect(
            this.x + 45, 
            this.y + headRadius * 2 + neckLength + 5, 
            10, 
            armLength, 
            [5]
        );
        ctx.fill();

        // Сигарета
        ctx.fillStyle = '#F8F8F8';
        ctx.fillRect(
            this.x + 55, 
            this.y + headRadius * 2 + neckLength + 15, 
            18, 
            2
        );
        // Тлеющий конец
        ctx.fillStyle = '#FF3300';
        ctx.beginPath();
        ctx.arc(
            this.x + 73, 
            this.y + headRadius * 2 + neckLength + 16, 
            2, 
            0, 
            Math.PI * 2
        );
        ctx.fill();
        // Дым (если игрок движется)
        if (Math.abs(this.vx) > 0) {
            ctx.fillStyle = 'rgba(200, 200, 200, 0.4)';
            ctx.beginPath();
            ctx.ellipse(
                this.x + 74 + Math.sin(Date.now()/200) * 2, 
                this.y + headRadius * 2 + neckLength + 10, 
                4, 
                8, 
                Math.PI/4, 
                0, 
                Math.PI
            );
            ctx.fill();
        }

        // ### Шорты ###
        ctx.fillStyle = '#CC0000';
        ctx.beginPath();
        ctx.moveTo(this.x + 15, this.y + headRadius * 2 + neckLength + torsoHeight);
        ctx.lineTo(this.x + 15, this.y + headRadius * 2 + neckLength + torsoHeight + 25);
        ctx.lineTo(this.x + 25, this.y + headRadius * 2 + neckLength + torsoHeight + 25);
        ctx.lineTo(this.x + 30, this.y + headRadius * 2 + neckLength + torsoHeight + 15);
        ctx.lineTo(this.x + 35, this.y + headRadius * 2 + neckLength + torsoHeight + 25);
        ctx.lineTo(this.x + 45, this.y + headRadius * 2 + neckLength + torsoHeight + 25);
        ctx.lineTo(this.x + 45, this.y + headRadius * 2 + neckLength + torsoHeight);
        ctx.closePath();
        ctx.fill();

        // Ремень
        ctx.fillStyle = '#2A190E';
        ctx.fillRect(
            this.x + 15, 
            this.y + headRadius * 2 + neckLength + torsoHeight, 
            shoulderWidth, 
            3
        );

        // ### Ноги ###
        // Левая нога
        ctx.fillStyle = '#F5D6B3';
        ctx.fillRect(
            this.x + 18, 
            this.y + headRadius * 2 + neckLength + torsoHeight + 25, 
            9, 
            legLength
        );
        
        // Правая нога
        ctx.fillRect(
            this.x + 33, 
            this.y + headRadius * 2 + neckLength + torsoHeight + 25, 
            9, 
            legLength
        );

        // ### Кроссовки ###
        ctx.fillStyle = '#333333';
        // Левый
        ctx.beginPath();
        ctx.roundRect(
            this.x + 15, 
            this.y + headRadius * 2 + neckLength + torsoHeight + 25 + legLength, 
            12, 
            8, 
            [3]
        );
        ctx.fill();
        // Правый
        ctx.beginPath();
        ctx.roundRect(
            this.x + 30, 
            this.y + headRadius * 2 + neckLength + torsoHeight + 25 + legLength, 
            12, 
            8, 
            [3]
        );
        ctx.fill();

        // ### Лицо (детализированное) ###
        // Глаза
        ctx.fillStyle = '#3A2B1E';
        ctx.beginPath();
        ctx.arc(
            this.x + 25, 
            this.y + headRadius - 2, 
            2, 
            0, 
            Math.PI * 2
        );
        ctx.arc(
            this.x + 35, 
            this.y + headRadius - 2, 
            2, 
            0, 
            Math.PI * 2
        );
        ctx.fill();
        
        // Рот
        ctx.strokeStyle = '#3A2B1E';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(
            this.x + 30, 
            this.y + headRadius + 5, 
            4, 
            Math.PI * 0.1, 
            Math.PI * 0.9
        );
        ctx.stroke();

        // Тень от кепки на лице
        ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
        ctx.beginPath();
        ctx.arc(
            this.x + 30, 
            this.y + headRadius + 2, 
            headRadius * 0.8, 
            Math.PI, 
            Math.PI * 2
        );
        ctx.fill();

        ctx.restore();

        // Отрисовка жизней
        this.drawLives();
    }
    drawHeart(x, y, size, color) {
    ctx.save();
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.moveTo(x + size/2, y + size/4);
    ctx.bezierCurveTo(x + size, y, x + size, y + size/2, x + size/2, y + size);
    ctx.bezierCurveTo(x, y + size/2, x, y, x + size/2, y + size/4);
    ctx.closePath();
    ctx.fill();
    
    // Обводка для лучшей видимости
    ctx.strokeStyle = 'rgba(0,0,0,0.5)';
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.restore();
  }
drawLives() {
    // Рисуем полупрозрачный фон для жизней
    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
    ctx.fillRect(
      WIDTH - 180, 10, 
      170, 34
    );
    
    // Рисуем сердца
    this.hearts.forEach((heart, index) => {
      if (index < this.lives) {
        this.drawHeart(heart.x, heart.y, heart.size, 'red');
      }
    });
  }
update(deltaTime) {
  
  this.x += this.vx * deltaTime;
  if (this.x > WIDTH) {
    this.x = -this.width;
  } 
  else if (this.x + this.width < 0) {
    this.x = WIDTH;
  }
  if (this.invulnerable) {
      this.invulnerableTimer += deltaTime;
      if (this.invulnerableTimer >= this.invulnerableDuration) {
        this.invulnerable = false;
        this.blinkEffect = false;
      }
    }
  if (this.x > canvas.width) this.x = -this.width;
  if (this.x + this.width < 0) this.x = canvas.width;

  if (this.currentPlatform?.isDestructible && 
    this.currentPlatform.damageProgress > 0.7) {
  this.fallThroughTimer += deltaTime;
  if (this.fallThroughTimer >= this.maxFallThroughTime) {
    this.onPlatform = false;
    this.currentPlatform = null;
  }
} else {
  this.fallThroughTimer = 0;
}

  this.vy += this.gravity * deltaTime;
  this.y += this.vy * deltaTime;

    this.onPlatform = false;
     this.wasOnPlatform = (this.currentPlatform !== null);
    for(let plat of platforms) {
    if(this.vy > 0 &&
       this.x + this.width > plat.x &&
       this.x < plat.x + plat.width &&
       this.y + this.height > plat.y &&
       this.y + this.height < plat.y + plat.height + this.vy * deltaTime) {
        if (plat.isDestructible && plat.damageProgress > 0.99) continue;
        this.y = plat.y - this.height;
        this.vy = 0;
        this.onPlatform = true;
        this.canJump = true;
        this.currentPlatform = plat; // Запоминаем текущую платформу
    }
  }
    if(!this.onPlatform && this.wasOnPlatform) {
      this.currentPlatform = null;
    }
}

 jump() {
    if (this.canJump && (this.onPlatform || !this.hasJumpedOnce)) {
      this.vy = -this.jumpPower;
      this.canJump = false;
      this.hasJumpedOnce = true; // Отмечаем первый прыжок
    }
  }
autoJump() {
  if (this.hasJumpedOnce && this.onPlatform) {
    const currentPlatform = platforms.find(plat => 
      this.y + this.height >= plat.y - 5 && 
      this.y + this.height <= plat.y + 5 &&
      this.x + this.width > plat.x &&
      this.x < plat.x + plat.width
    );
    
    // Прыгаем в любом случае, если платформа разрушается
    if (currentPlatform?.isDestructible && currentPlatform.isDestroying) {
      this.vy = -this.jumpPower * 0.8; // Чуть слабее прыжок
      this.canJump = false;
      return;
    }
    
    // Оригинальная логика для обычных платформ
    if (!currentPlatform?.isDestructible || 
       (currentPlatform.isDestructible && currentPlatform.damageProgress < 0.7)) {
      this.vy = -this.jumpPower;
      this.canJump = false;
    }
  }
}
}



class Enemy {
  constructor(x, y, type, vx) {
    this.x = x;
    this.y = y;
    this.width = 90;
    this.height = 30;
    this.type = type;
    this.vx = vx !== undefined ? vx : (100 + Math.random() * 200) * (Math.random() < 0.5 ? 1 : -1);
  }
update(deltaTime) {
  this.x += this.vx * deltaTime;

  if (this.x < 0) {
    this.x = 0;
    this.vx = -this.vx;
    this.x += this.vx * deltaTime;  // двигаем немного внутрь
  }
  if (this.x + this.width > WIDTH) {
    this.x = WIDTH - this.width;
    this.vx = -this.vx;
    this.x += this.vx * deltaTime;  // двигаем немного внутрь
  }
}
  draw() {
    switch(this.type) {
      case 'salad':
        this.drawSalad();
        break;
      case 'bone':
        this.drawBone();
        break;
      case 'azbuka':
        this.drawAzbuka();
        break;
      case 'boat':
        this.drawBoat();
        break;
      default:
        this.drawDefault();
    }
  }
drawSalad() {
  let plateX = this.x + 45;
  let plateY = this.y + 23;
  let plateRadiusX = 42;
  let plateRadiusY = 15;

  // Тарелка с градиентом и бликом
  let plateGrad = ctx.createRadialGradient(plateX, plateY, plateRadiusY / 2, plateX, plateY, plateRadiusX);
  plateGrad.addColorStop(0, '#e6e3ca');
  plateGrad.addColorStop(1, '#cfc8a4');
  ctx.fillStyle = plateGrad;
  ctx.beginPath();
  ctx.ellipse(plateX, plateY, plateRadiusX, plateRadiusY, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = '#9f966a';
  ctx.lineWidth = 2;
  ctx.stroke();

  // --- Огурец: длинный с легким изгибом и текстурой ---
  ctx.fillStyle = '#4a7c4a';
  ctx.beginPath();
  ctx.ellipse(this.x + 30, this.y + 20, 17, 7, -0.3, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = '#356734';
  ctx.lineWidth = 1.5;
  ctx.stroke();

  // Точки на огурце — "пупырышки"
  ctx.fillStyle = '#3b6b3b';
  for (let i = 0; i < 7; i++) {
    ctx.beginPath();
    ctx.ellipse(this.x + 23 + i * 5, this.y + 20 + (i % 2 ? 3 : -3), 2, 2.5, 0, 0, Math.PI * 2);
    ctx.fill();
  }
  // Блик огурца
  let cucumberGrad = ctx.createRadialGradient(this.x + 25, this.y + 18, 1, this.x + 30, this.y + 20, 12);
  cucumberGrad.addColorStop(0, 'rgba(255,255,255,0.45)');
  cucumberGrad.addColorStop(1, 'rgba(255,255,255,0)');
  ctx.fillStyle = cucumberGrad;
  ctx.beginPath();
  ctx.ellipse(this.x + 25, this.y + 18, 9, 3.5, -0.3, 0, Math.PI * 2);
  ctx.fill();

  // --- Помидор: круглый, ярко красный с обводкой и бликами ---
  ctx.fillStyle = '#d63333';
  ctx.beginPath();
  ctx.ellipse(this.x + 60, this.y + 20, 12, 12, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = '#8b0000';
  ctx.lineWidth = 1.8;
  ctx.stroke();

  // Блик помидора
  let tomatoGrad = ctx.createRadialGradient(this.x + 56, this.y + 16, 1, this.x + 60, this.y + 20, 12);
  tomatoGrad.addColorStop(0, 'rgba(255,255,255,0.8)');
  tomatoGrad.addColorStop(1, 'rgba(255,255,255,0)');
  ctx.fillStyle = tomatoGrad;
  ctx.beginPath();
  ctx.ellipse(this.x + 56, this.y + 16, 7, 7, 0, 0, Math.PI * 2);
  ctx.fill();

  // --- Лист салата: более волнистый, ярко-зеленый с прожилками ---
  ctx.fillStyle = '#67b64f';
  ctx.beginPath();
  ctx.moveTo(this.x + 45, this.y + 10);
  ctx.bezierCurveTo(this.x + 35, this.y + 2, this.x + 25, this.y + 32, this.x + 45, this.y + 30);
  ctx.bezierCurveTo(this.x + 60, this.y + 26, this.x + 55, this.y + 12, this.x + 45, this.y + 10);
  ctx.fill();
  ctx.strokeStyle = '#2e5f19';
  ctx.lineWidth = 2;
  ctx.stroke();

  // Прожилки — светлыми линиями
  ctx.strokeStyle = 'rgba(255,255,255,0.4)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(this.x + 45, this.y + 11);
  ctx.lineTo(this.x + 36, this.y + 17);
  ctx.moveTo(this.x + 45, this.y + 16);
  ctx.lineTo(this.x + 34, this.y + 25);
  ctx.moveTo(this.x + 45, this.y + 20);
  ctx.lineTo(this.x + 50, this.y + 25);
  ctx.stroke();

  // --- Перец: яркий желтый с четкой формой и бликами ---
  ctx.fillStyle = '#f5d63d';
  ctx.beginPath();
  ctx.ellipse(this.x + 50, this.y + 27, 9, 6, 0.3, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = '#c5a72a';
  ctx.lineWidth = 1.5;
  ctx.stroke();

  // Блик перца
  ctx.fillStyle = '#fff8b3';
  ctx.beginPath();
  ctx.ellipse(this.x + 48, this.y + 25, 5, 2.5, 0.3, 0, Math.PI * 2);
  ctx.fill();
}

 drawBone() {
  // Центр кости
  const centerX = this.x + this.width / 2;
  const centerY = this.y + this.height / 2;

  ctx.lineWidth = 2;
  ctx.strokeStyle = '#999988';

  // Цвет кости
  ctx.fillStyle = '#e6e6e0';

  // Левая "шарик" — уменьшенный овал
  ctx.beginPath();
  ctx.ellipse(centerX - 25, centerY, 8, 10, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.stroke();

  // Правая "шарик"
  ctx.beginPath();
  ctx.ellipse(centerX + 25, centerY, 8, 10, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.stroke();

  // Соединение — уменьшенное плавное соединение
  ctx.beginPath();
  ctx.moveTo(centerX - 18, centerY - 8);
  ctx.bezierCurveTo(centerX - 10, centerY - 6, centerX + 10, centerY - 6, centerX + 18, centerY - 8);
  ctx.lineTo(centerX + 18, centerY + 8);
  ctx.bezierCurveTo(centerX + 10, centerY + 6, centerX - 10, centerY + 6, centerX - 18, centerY + 8);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();

  // Текстура — мелкие серые пятна
  ctx.fillStyle = '#b0b09e';
  for (let i = 0; i < 12; i++) {
    let px = centerX - 20 + Math.random() * 40;
    let py = centerY - 8 + Math.random() * 16;
    ctx.beginPath();
    ctx.ellipse(px, py, 2, 1.5, Math.random() * Math.PI, 0, Math.PI * 2);
    ctx.fill();
  }
}


drawAzbuka() {
  let rectWidth = 40;
  let rectHeight = 60;
  let posX = this.x + (this.width - rectWidth) / 2;
  let posY = this.y - 25;

  // Рисуем объемную обложку книги с градиентом
  let coverGrad = ctx.createLinearGradient(posX, posY, posX + rectWidth, posY + rectHeight);
  coverGrad.addColorStop(0, '#3f51b5');
  coverGrad.addColorStop(0.5, '#1a237e');
  coverGrad.addColorStop(1, '#283593');
  ctx.fillStyle = coverGrad;
  ctx.fillRect(posX, posY, rectWidth, rectHeight);

  // Добавляем тень и подсветку для объема
  ctx.strokeStyle = '#1c2a72';
  ctx.lineWidth = 2;
  ctx.strokeRect(posX, posY, rectWidth, rectHeight);

  // Левая "переплетная" полоса книги
  let spineWidth = 6;
  let spineGrad = ctx.createLinearGradient(posX, posY, posX + spineWidth, posY + rectHeight);
  spineGrad.addColorStop(0, '#283593');
  spineGrad.addColorStop(1, '#1a237e');
  ctx.fillStyle = spineGrad;
  ctx.fillRect(posX, posY, spineWidth, rectHeight);

  // Добавляем тонкие линии на переплете
  ctx.strokeStyle = '#151f4e';
  ctx.lineWidth = 1;
  for (let i = 1; i <= 3; i++) {
    ctx.beginPath();
    ctx.moveTo(posX + i * 2, posY);
    ctx.lineTo(posX + i * 2, posY + rectHeight);
    ctx.stroke();
  }

  // Рисуем мелкие буквы по обложке, раскиданные рандомно
  const smallLetters = 'АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ';
  ctx.fillStyle = 'rgba(255, 255, 255, 0.12)';
  ctx.font = 'bold 8px Arial';

  for (let i = 0; i < 25; i++) {
    let letter = smallLetters[Math.floor(Math.random() * smallLetters.length)];
    let x = posX + 10 + Math.random() * (rectWidth - 15);
    let y = posY + 5 + Math.random() * (rectHeight - 10);
    let angle = (Math.random() - 0.5) * 0.5; // чуть наклонить буквы
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(angle);
    ctx.fillText(letter, 0, 0);
    ctx.restore();
  }

  // Основной текст "АЗБУКА" с эффектами (тень + легкий градиент)
  const mainText = ['АЗ', 'БУКА'];

  // Определяем максим размер шрифта, чтобы текст помещался
  let fontSize = 18;
  function fits(text, size) {
    ctx.font = `bold ${size}px Arial`;
    return ctx.measureText(text).width <= rectWidth - 8;
  }
  while (!fits(mainText[0], fontSize) || !fits(mainText[1], fontSize)) {
    fontSize--;
    if (fontSize < 10) break;
  }

  ctx.font = `bold ${fontSize}px Arial`;
  ctx.textBaseline = 'top';

  // Центрируем вертикально по всей обложке: сдвигаем текст чуть выше центра
  // Вместо просто rectHeight/2, поднимаем на 3 пикселя
  let lineHeight = fontSize + 4;
  let startY = posY + rectHeight / 2 - lineHeight / 2 - 3;

  // Тень текста
  ctx.shadowColor = 'rgba(0,0,0,0.6)';
  ctx.shadowOffsetX = 1.5;
  ctx.shadowOffsetY = 1.5;
  ctx.shadowBlur = 2;

  // Градиент заливки текста
  let textGrad = ctx.createLinearGradient(posX, startY, posX + rectWidth, startY + lineHeight * 2);
  textGrad.addColorStop(0, '#e1e8ff');
  textGrad.addColorStop(1, '#82aaff');
  ctx.fillStyle = textGrad;

  // Рисуем первую строку "АЗ" по центру по ширине
  ctx.textAlign = 'center';
  ctx.fillText(mainText[0], posX + rectWidth / 2, startY);

  // Вторая строка "БУКА" чуть сдвинута влево, чтобы не заходить на переплет
  ctx.textAlign = 'left';
  let buкаX = posX + spineWidth + 3; // отступ от края переплета + 3px
  ctx.fillText(mainText[1], buкаX, startY + lineHeight);

  // Сброс тени
  ctx.shadowColor = 'transparent';
  ctx.shadowOffsetX = 0;
  ctx.shadowOffsetY = 0;
  ctx.shadowBlur = 0;
}


drawBoat() {
  const x = this.x;
  const y = this.y;
  const w = this.width || 100;
  const h = this.height || 50;

  ctx.lineJoin = 'round';
  ctx.lineCap = 'round';

  // Корпус - белый, гладкий, с небольшим закруглением
  ctx.fillStyle = '#ffffff';
  ctx.strokeStyle = '#7a7a7a';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(x + 10, y + h * 0.8);
  ctx.quadraticCurveTo(x + w * 0.15, y + h * 0.4, x + w * 0.4, y + h * 0.4);
  ctx.lineTo(x + w * 0.85, y + h * 0.4);
  ctx.quadraticCurveTo(x + w * 0.95, y + h * 0.4, x + w * 0.95, y + h * 0.65);
  ctx.lineTo(x + w * 0.85, y + h * 0.85);
  ctx.lineTo(x + 10, y + h * 0.85);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();

  // Рубка - высокий прямоугольник с закругленными углами, светло-серый
  ctx.fillStyle = '#d0d4d9';
  ctx.strokeStyle = '#7a7a7a';
  ctx.lineWidth = 1.5;
  const cabinX = x + w * 0.5;
  const cabinY = y + h * 0.15;
  const cabinW = w * 0.35;
  const cabinH = h * 0.4;
  const radius = 8;

  ctx.beginPath();
  ctx.moveTo(cabinX + radius, cabinY);
  ctx.lineTo(cabinX + cabinW - radius, cabinY);
  ctx.quadraticCurveTo(cabinX + cabinW, cabinY, cabinX + cabinW, cabinY + radius);
  ctx.lineTo(cabinX + cabinW, cabinY + cabinH - radius);
  ctx.quadraticCurveTo(cabinX + cabinW, cabinY + cabinH, cabinX + cabinW - radius, cabinY + cabinH);
  ctx.lineTo(cabinX + radius, cabinY + cabinH);
  ctx.quadraticCurveTo(cabinX, cabinY + cabinH, cabinX, cabinY + cabinH - radius);
  ctx.lineTo(cabinX, cabinY + radius);
  ctx.quadraticCurveTo(cabinX, cabinY, cabinX + radius, cabinY);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();

  // Окна рубки - три голубых прямоугольника с бликами
  const windowW = cabinW / 5;
  const windowH = cabinH / 3;
  ctx.fillStyle = '#a9c9ff';
  ctx.strokeStyle = '#6a8fc9';
  ctx.lineWidth = 1;
  for (let i = 0; i < 3; i++) {
    let wx = cabinX + windowW * 0.7 + i * (windowW + 5);
    let wy = cabinY + cabinH / 4;
    ctx.beginPath();
    ctx.rect(wx, wy, windowW, windowH);
    ctx.fill();
    ctx.stroke();

    // Блик
    let grad = ctx.createRadialGradient(wx + windowW * 0.3, wy + windowH * 0.3, 2, wx + windowW * 0.3, wy + windowH * 0.3, windowW);
    grad.addColorStop(0, 'rgba(255, 255, 255, 0.7)');
    grad.addColorStop(1, 'rgba(255, 255, 255, 0)');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.rect(wx, wy, windowW, windowH);
    ctx.fill();
  }

  // Корма (задняя часть) - чуть поднята и заокруглена, тёмно-серая
  ctx.fillStyle = '#808080';
  ctx.beginPath();
  ctx.moveTo(x + w * 0.9, y + h * 0.4);
  ctx.lineTo(x + w * 0.98, y + h * 0.4);
  ctx.lineTo(x + w * 0.98, y + h * 0.7);
  ctx.quadraticCurveTo(x + w * 0.9, y + h * 0.8, x + w * 0.85, y + h * 0.7);
  ctx.closePath();
  ctx.fill();

  // Блики на корпусе (две мягкие дуги белым)
  ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.moveTo(x + 15, y + h * 0.6);
  ctx.quadraticCurveTo(x + w * 0.3, y + h * 0.45, x + w * 0.6, y + h * 0.5);
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(x + w * 0.3, y + h * 0.55);
  ctx.quadraticCurveTo(x + w * 0.5, y + h * 0.42, x + w * 0.7, y + h * 0.48);
  ctx.stroke();
}
}

let player;
let platforms = [];
let enemies = [];

const enemyTypes = ['salad', 'bone', 'azbuka', 'boat'];
let lastEnemyTypes = [];

function generateEnemies(count) {
  let enemiesArray = [];
  let usedYs = new Set();

  for (let i = 0; i < count; i++) {
    let y;
    do {
      y = Math.random() * (HEIGHT - 200);
      y = Math.floor(y / 50) * 50;
    } while (usedYs.has(y));
    usedYs.add(y);

    let x, tooClose;
    let attempts = 0;
    do {
      tooClose = false;
      x = Math.random() * (WIDTH - 50);
      for (let enemy of enemiesArray) {
        if (Math.abs(enemy.x - x) < 200) {
          tooClose = true;
          break;
        }
      }
      attempts++;
      if (attempts > 100) break; // избегаем вечного цикла
    } while (tooClose);

    // Выбираем тип врага, избегая 3 подряд одинаковых
    let availableTypes = [...enemyTypes];
    if (
      lastEnemyTypes.length >= 2 &&
      lastEnemyTypes[lastEnemyTypes.length - 1] === lastEnemyTypes[lastEnemyTypes.length - 2]
    ) {
      availableTypes = availableTypes.filter(
        type => type !== lastEnemyTypes[lastEnemyTypes.length - 1]
      );
    }

    const type = availableTypes[Math.floor(Math.random() * availableTypes.length)];
    lastEnemyTypes.push(type);
    if (lastEnemyTypes.length > 2) lastEnemyTypes.shift();

    enemiesArray.push(new Enemy(x, y, type));
  }

  return enemiesArray;
}

function lerp(a, b, t) {
    return a + (b - a) * t;
}

function initGame() {
  player = new Player();
  player.lives = 3; 
  platforms = [];
  enemies = generateEnemies(3); 
  score = 0;
  visualScore = 0;
  totalHeight = 0;
  lastPlayerY = HEIGHT;
  maxHeightReached = HEIGHT; // Начинаем с нижней точки (высота canvas)
  baseHeight = HEIGHT; // 
  player.hasJumpedOnce = false;
  player.currentPlatform = null;
  // Платформа под игроком
  platforms.push(new Platform(player.x, player.y + player.height));

  // Настройки генерации платформ:
  const PLATFORM_COUNT = 11; // Увеличили с ~7 до 30 платформ
  const MIN_VERTICAL_DIST = 80; // Минимальное расстояние по вертикали (было 150)
  const MAX_VERTICAL_DIST = 120; // Максимальное расстояние
  
  let y = HEIGHT - 150;
  
  for (let i = 0; i < PLATFORM_COUNT; i++) {
    // Случайный интервал между платформами
    y -= MIN_VERTICAL_DIST + Math.random() * (MAX_VERTICAL_DIST - MIN_VERTICAL_DIST);
    
    // Позиция по X (с отступами от краев)
    let x = 45 + Math.random() * (WIDTH - 180);
    
    // 15% chance что платформа разрушаемая
    let isDestructible = Math.random() < 0.75;
    
    platforms.push(new Platform(x, y, isDestructible));
    
    // 25% chance добавить вторую платформу на этом уровне
    if(Math.random() < 0.25 && i < PLATFORM_COUNT - 1) {
      let x2;
      do {
        x2 = 45 + Math.random() * (WIDTH - 180);
      } while(Math.abs(x2 - x) < 200); // Чтобы не пересекались
      
      platforms.push(new Platform(x2, y, Math.random() < 0.15));
      i++; // Учитываем добавленную платформу
    }
  }

  score = 0;
  scoreDiv.style.display = 'block';
  scoreDiv.textContent = `Очки: ${score}`;
  gameOver = false;
}
  
let lastFrameTime = 0;
let smoothedDeltaTime = 1 / 60; 
const maxDeltaTime = 0.05; 

function checkCollision(player, enemy) {
  return player.x < enemy.x + enemy.width &&
         player.x + player.width > enemy.x &&
         player.y < enemy.y + enemy.height &&
         player.y + player.height > enemy.y;
}

function gameLoop(currentTime) {
   if (!lastFrameTime) {
    lastFrameTime = currentTime;
  }
  const currentHeight = player.y;
  const deltaTime = (currentTime - lastFrameTime) / 1000;
  lastFrameTime = currentTime;

  if (!gameStarted || gameOver) return;

  if (currentHeight < maxHeightReached) {
        const heightDifference = maxHeightReached - currentHeight; // Насколько выше стал
        score += heightDifference * 0.5; // Коэффициент (можно настроить)
        maxHeightReached = currentHeight; // Обновляем рекорд
        
        // Эффект при обновлении счёта
        scoreDiv.classList.add('bounce');
        setTimeout(() => scoreDiv.classList.remove('bounce'), 200);
    }


  // Проверка на выход за нижнюю границу экрана
  if (player.y > HEIGHT) {
    gameOver = true;
    scoreDiv.style.display = 'none';
    gameOverScreen.style.display = 'flex';
    return;
  }
  document.getElementById('livesCount').textContent = player.lives;
  // Очистка экрана
  ctx.clearRect(0, 0, WIDTH, HEIGHT);

  // Обработка управления
  handleMovement();
  
if (player.y < lastPlayerY) {
        const heightDiff = lastPlayerY - player.y;
        totalHeight += heightDiff;
        score = Math.floor(totalHeight * heightScoreMultiplier);
        
        // Эффект при обновлении счета
        scoreDiv.classList.add('bounce');
        setTimeout(() => scoreDiv.classList.remove('bounce'), 200);
    }
    lastPlayerY = player.y;

  // Обновление игрока
  player.update(deltaTime);
  if (!player.invulnerable) {
    enemies.forEach(enemy => {
      if (checkCollision(player, enemy)) {
        if (player.loseLife()) {
          // Отбрасывание игрока при ударе
          player.vy = -300;
          
          if (player.lives <= 0) {
            endGame();
          }
        }
      }
    });
}
// if (scoreAnimationFrame) cancelAnimationFrame(scoreAnimationFrame);

function animateScore() {
    const diff = score - visualScore;
    if (Math.abs(diff) > 1) {
        visualScore += diff * 0.1;
        scoreDiv.textContent = `Очки: ${Math.floor(visualScore)}`;
        scoreAnimationFrame = requestAnimationFrame(animateScore);
    } else {
        visualScore = score;
        scoreDiv.textContent = `Очки: ${Math.floor(visualScore)}`;
    }
}
// animateScore();
// Плавное обновление визуального счета
if (Math.abs(visualScore - score) > 1) {
    visualScore += (score - visualScore) * SCORE_SPEED;
} else {
    visualScore = score;
}
scoreDiv.textContent = `Очки: ${Math.floor(visualScore)}`;
  let playerOnPlatform = false;
   // Обработка платформ
for (let i = platforms.length - 1; i >= 0; i--) {
  const plat = platforms[i];
  const isCurrent = (player.currentPlatform === plat);

  // Запускаем разрушение при любом контакте с разрушаемой платформой после первого прыжка
  if (isCurrent && plat.isDestructible && player.hasJumpedOnce) {
    plat.startDestruction();
  }

  // Обновляем состояние разрушения
  if (plat.isDestructible && plat.isDestroying) {
    if (plat.update(deltaTime)) {
      platforms.splice(i, 1);
      score += 10;
      scoreDiv.textContent = `Очки: ${score}`;
      if (isCurrent) {
        player.vy = -400;
        player.currentPlatform = null;
      }
    }
  }
}

  // Автопрыжок после первого прыжка
  if (player.hasJumpedOnce && player.onPlatform) {
    player.autoJump();
  }

  // Прокрутка мира
  if (player.y < HEIGHT / 2) {
    const diff = HEIGHT / 2 - player.y;
    player.y = HEIGHT / 2;

    // Сдвигаем все платформы
    platforms.forEach(plat => {
        plat.y += diff;
        
        // Перемещаем платформы, вышедшие за экран
        if (plat.y > HEIGHT) {
            plat.y = -30;
            plat.x = Math.random() * (WIDTH - plat.width);
            plat.isDestructible = Math.random() < 0.15;
            plat.damageProgress = 0;
        }
    });

    // Сдвигаем врагов
    enemies.forEach(enemy => {
        enemy.y += diff;
        if (enemy.y > HEIGHT) {
            enemy.y = -50;
            enemy.x = Math.random() * (WIDTH - enemy.width);
            enemy.vx = (Math.random() * 200 + 100) * (Math.random() < 0.5 ? 1 : -1);
        }
    });
  }

  // Обновляем врагов
  enemies.forEach(enemy => {
    enemy.update(deltaTime);
  });

  // Рисуем платформы
platforms.forEach(plat => {
  const isCurrent = (player.currentPlatform === plat);
  plat.draw(isCurrent);
});

  // Рисуем врагов
  enemies.forEach(enemy => {
    enemy.draw();
  });

  // Рисуем игрока
  player.draw();

  // Запускаем следующий кадр
  requestAnimationFrame(gameLoop);
}
// Управление

const leftBtn = document.getElementById('leftBtn');
const rightBtn = document.getElementById('rightBtn');
// Кнопка прыжка убрана из мобильных интерфейсов

let leftPressed = false;
let rightPressed = false;

document.addEventListener('keydown', e => {
  if(e.code === 'ArrowLeft') leftPressed = true;
  if(e.code === 'ArrowRight') rightPressed = true;
  if(e.code === 'ArrowUp' || e.code === 'Space'){
    // Прыгаем только если первый прыжок не сделан (как в мобиле)
    if(!player.firstJumpDone) {
      player.jump();
    }
  }
});

document.addEventListener('keyup', e => {
  if(e.code === 'ArrowLeft') leftPressed = false;
  if(e.code === 'ArrowRight') rightPressed = false;
});

leftBtn.addEventListener('touchstart', e => { e.preventDefault(); leftPressed = true; });
leftBtn.addEventListener('touchend', e => { e.preventDefault(); leftPressed = false; });
rightBtn.addEventListener('touchstart', e => { e.preventDefault(); rightPressed = true; });
rightBtn.addEventListener('touchend', e => { e.preventDefault(); rightPressed = false; });

canvas.addEventListener('touchstart', e => {
  if(!player.hasJumpedOnce) {
    player.jump();
  }
  e.preventDefault();
});

canvas.addEventListener('mousedown', e => {
  if(!player.hasJumpedOnce) {
    player.jump();
  }
});

document.addEventListener('keydown', e => {
  if((e.code === 'ArrowUp' || e.code === 'Space') && !player.hasJumpedOnce) {
    player.jump();
  }
});

// Обработка движения в gameLoop
function handleMovement() {
  if(leftPressed) {
    player.vx = -player.speedX;
  } else if(rightPressed) {
    player.vx = player.speedX;
  } else {
    player.vx = 0;
  }
}

function checkPlayerPlatformContact(player, platform) {
  return (
    player.y + player.height >= platform.y - 5 &&
    player.y + player.height <= platform.y + 5 &&
    player.x + player.width > platform.x &&
    player.x < platform.x + platform.width &&
    player.vy >= 0
  );
}

function handlePlatformContact(player, platform) {
  player.y = platform.y - player.height;
  player.vy = 0;
  player.onPlatform = true;
  player.canJump = true;
}

function endGame() {
  gameOver = true;
  scoreDiv.style.display = 'none';
  gameOverScreen.style.display = 'flex';
  document.querySelector('#gameOverScreen div').textContent = `Игра окончена! Очки: ${score}`;
}

// Запуск игры

startBtn.onclick = () => {
  startScreen.style.display = 'none';
  loadingScreen.style.display = 'flex';
  setTimeout(() => {
    loadingScreen.style.display = 'none';
    gameStarted = true;
    gameOver = false;
    initGame();
    
    if(/Mobi|Android/i.test(navigator.userAgent)) {
      document.getElementById('mobileControls').style.display = 'block';
    }

    // Запускаем игровой цикл правильно:
    lastFrameTime = 0;
    function loop() {
      if(gameStarted && !gameOver) {
        requestAnimationFrame(loop);
        gameLoop(performance.now()); // Явно передаем текущее время
      }
    }
    loop();
  }, 1000);
};

restartBtn.onclick = () => {
  gameOverScreen.style.display = 'none';
  gameStarted = true;
  initGame();
  scoreDiv.style.display = 'block';
  gameOver = false;
  // Снова запускаем игровой цикл
  function loop() {
    if(!gameOver) {
      gameLoop(performance.now());
      handleMovement();
      requestAnimationFrame(loop);
    } else {
      scoreDiv.style.display = 'none';
      gameOverScreen.style.display = 'flex';
    }
  }
  loop();
};

</script>
</body>
</html>
